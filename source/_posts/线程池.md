---
title: 线程池
date: 2019-08-05 14:46:05
tags:
- Java
- Concurrent
- ThreadPool
categories:
- Java
- Concurrent
- ThreadPool
---
## 线程池

### 概述

​		线程池作用就是限制系统中执行线程的数量。 根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果。 少了浪费了系统资源，多了造成系统拥挤效率不高。 用线程池控制线程数量，其他线程排 队等候。 一个任务执行完毕，再从队列的中取最前面的任务开始执行。 若队列中没有等待进程，线程池的这一资源处于等待。 当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。 

------

### Executor

​		`Executor`是线程池的顶级接口，定义了方法`execute(Runnable r)`，接收一个Runnable实例，用来执行一个任务，该任务即是一个实现Runnable接口的类。

源码：

```java
public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be
     * accepted for execution
     * @throws NullPointerException if command is null
     */
    void execute(Runnable command);
}
```

------

### ExecutorService

​		继承自`Executor`，提供了更多的方法调用。

- `ExecutorService`生命周期

  运行 - Running 、关闭 - shuttingdown、终止 - terminated

  　Running ： 线程池正在执行中，活动状态。创建后即进入此状态

  　shuttingdown ： 优雅关闭，线程池正在关闭中。不再接收新的线程任务，已有的任务（正在处理的 + 队列中阻塞的），处理完毕后，关闭线程池。调用shutdown()方法，即进入此状态

  　terminated ： 线程池已关闭。

- `submit`方法

  ​	有返回值，`Future`类型。重载了方法，`submit(Runnable)`不需要提供返回值。`submit(Callable)`、`submit(Runnable，T)`可以提供线程执行后的结果返回值。

- Future

  ​	线程执行完毕结果。获取线程执行结果是通过`get()`方法获取。`get()`无参，阻塞等待线程执行结束。`get(long timeout, TimeUnit unit)`有参，阻塞等待固定时长，超时未获取，则抛出异常。

  ```java
  public class T06_Future {
  	public static void main(String[] args) throws InterruptedException, ExecutionException {
  		FutureTask<Integer> task = new FutureTask<Integer>(()->{
  			TimeUnit.MILLISECONDS.sleep(500);
  			return 1000;
  		});
  		/*FutureTask<Integer> task = new FutureTask<Integer>(new Callable() {
  			@Override
  			public Integer call() throws Exception {
  				TimeUnit.MILLISECONDS.sleep(500);
  				return 1000;
  			}
  		});*/
  		new Thread(task).start();
  		
  		System.out.println(task.get());//阻塞方法
  		
  		ExecutorService service = Executors.newFixedThreadPool(5);
  		Future<Integer> f = service.submit(()->{
  			TimeUnit.MILLISECONDS.sleep(500);
  			return 1;
  		});
  		System.out.println(f.get());
  		System.out.println(f.isDone());
  		service.shutdown();
  	}
  }
  ```

  

- Callable

  ​	类似Runnable的一个线程接口。其中的对应run的方法是call方法。此接口提供了线程执行完毕返回值。

------

### Executors

​		`Executors`工具类，提供了很多的工厂方法用于创建线程，返回的线程池都实现了`ExecutorService`接口。常用的线程池有`FixedThreadPool`,`CachedThreadPool`,`SingleThreadExecutor`,`ScheduledThreadPool`,`WorkStealingPool`等。

------

### 常用线程池

#### FixedThreadPool

​		创建一个定长的线程池，可以控制线程最大并发数，使用`LinkedBlockingQueue`作为任务队列，当任务数量大于线程池容量的时候，未执行的任务进入任务等待队列`LinkedBlockingQueue`中，当线程有空闲的时候，自动从队列中取出任务执行。

源码：

> Executors.class

```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

> ThreadPoolExecutor.class

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

示例：

```java
public class T05_ThreadPool {
	public static void main(String[] args) throws InterruptedException {
		ExecutorService service = Executors.newFixedThreadPool(5);
		for(int i = 0; i < 6; i++) {
			service.execute(()->{
				try {
					TimeUnit.MILLISECONDS.sleep(500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName());
			});
		}
		System.out.println(service);
		
		service.shutdown();
		System.out.println(service.isTerminated());//任务是否执行完
		System.out.println(service.isShutdown());//任务是否ShutDown(过程)，要执行完任务
		System.out.println(service);
		
		TimeUnit.SECONDS.sleep(5);
		
		System.out.println(service.isTerminated());		
		System.out.println(service.isShutdown());
		System.out.println(service);
	}
}
```

------

#### CachePool

​		缓存线程池，容量 `0-Integer.MAX_VALUE`，自动根据任务数扩容：如果线程池中的线程数不满足任务执行需求，则创建新的线程并添加到池中。生命周期默认60s，当线程空闲时长到60s的时候，自动终止销毁释放线程，移除线程池。

源码：

```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

示例：

```java
public class T08_CachedPool {
	public static void main(String[] args) throws InterruptedException {
		ExecutorService service = Executors.newCachedThreadPool();
		System.out.println(service);
		//弹性线程池 用的时候才起线程
		for(int i = 0; i < 2; i++) {
			service.execute(()->{
				try {
					TimeUnit.MILLISECONDS.sleep(500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName());
			});
		}
		System.out.println(service);
		TimeUnit.SECONDS.sleep(65);//cache默认60s生命周期
		System.out.println(service);
	}
}
```

------

#### SingleThreadPool

​		单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

源码：

```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```

示例：

```java
public class T09_SingleThreadPool {
	public static void main(String[] args) {
		ExecutorService service = Executors.newSingleThreadExecutor();
		for(int i = 0; i < 5; i++) {
			final int j = i;
			service.execute(()->{
				System.out.println(j + " " + Thread.currentThread().getName());
			});
		}
		service.shutdown();
	}
}
```

------

#### ScheduledPool

​		创建一个定长线程池，支持定时及周期性任务执行。延迟执行.

源码：

> Executors.class

```java
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
```

> ScheduledThreadPoolExecutor.class

```java
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
```

示例：

```java
public class T10_ScheduledPool {
	public static void main(String[] args) {
		ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
		service.scheduleAtFixedRate(()->{
			try {
				TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName());
		}, 0, 500, TimeUnit.MILLISECONDS);
	}
}
```

------

#### 自定义线程池

​		自定义线程池，可以使用`ThreadPoolExecutor`类来进行创建管理。线程池中，除了`ForkJoinPool`外，其他常用的线程池底层，都是使用`ThreadPoolExecutor`实现的。

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

`corePoolSize`:核心线程数，也是最少线程数。在创建线程池时，默认情况下，是不会创建线程池的，也即此时的线程池中线程数为0，直到有任务来临时，才会去创建线程。当然，手动调用`prestartCoreThread()`或者`prestartAllCoreThreads()`方法，可以初始化创建线程池中的线程。默认情况下，当有任务来临时，就会创建新的线程去处理执行，即使此时线程池中有空闲的线程。当线程数达到`corePoolSize`时，线程数不增加，此时任务会放入等待队列`BlockingQueue`中。

`maximumPoolSize`:最大线程数。当阻塞队列满了，开始扩充线程池中的线程数。直到达到此最大值的时候。

`keepAliveTime`:表示线程空闲存活时间。

`unit`:时间单位

`workQueue`：阻塞队列，用来存储等待执行任务的资源

------

#### ForkJoin框架

​		拆分合并，将一个大的任务，拆分成若干子任务，并最终汇总子任务的执行结果，得到大任务的执行结果。并行执行，采用工作窃取机制，更加有效的利用cpu资源。

主要类：

​		`ForkJoinPool` ： 用于执行Task。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他未完成工作线程的队列的尾部获取一个任务。

​		`ForkJoinTask`：`ForkJoin`任务，提供在任务中执行fork()和join()操作的机制（二叉分逻辑），通常不直接继承`ForkJoinTask`类，而是继承抽象子类`RecursiveTask`（有返回结果） 或者` RecursiveAction `（无返回结果）。

​		`ForkJoinWorkerThread`：`ForkJoinPool` 内部的worker thread，用来具体执行`ForkJoinTask`。内部有 `ForkJoinPool.WorkQueue`，来保存要执行的 `ForkJoinTask`。

　　`ForkJoinPool.WorkQueue`：保存要执行的`ForkJoinTask`。

##### WorkStealingPool

​		获取当前可用的线程数量进行创建作为并行级别，使用`ForkJoinPool`实现。

源码：

> Executors.class

```java
    public static ExecutorService newWorkStealingPool() {
        return new ForkJoinPool
            (Runtime.getRuntime().availableProcessors(),
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }
```

> ForkJoinPool.class

```java
    public ForkJoinPool(int parallelism,
                        ForkJoinWorkerThreadFactory factory,
                        UncaughtExceptionHandler handler,
                        boolean asyncMode) {
        this(checkParallelism(parallelism),
             checkFactory(factory),
             handler,
             asyncMode ? FIFO_QUEUE : LIFO_QUEUE,
             "ForkJoinPool-" + nextPoolId() + "-worker-");
        checkPermission();
    }
```

示例：

```java
public class T11_WorkStealingPool {
	public static void main(String[] args) throws IOException {
		ExecutorService service = Executors.newWorkStealingPool();
		System.out.println(Runtime.getRuntime().availableProcessors());//可用线程数
		//daemon 精灵线程  在后台运行
		service.execute(new R(3000));
		service.execute(new R(2000));
		service.execute(new R(2000));
		service.execute(new R(2000));
		service.execute(new R(2000));
		//由于产生的是精灵线程（守护线程，后台线程），主线程不阻塞的话，看不到输出
		System.in.read();
	}
	static class R implements Runnable{
		int time;
		R(int t){
			this.time = t;
		}
		@Override
		public void run() {
			try {
				TimeUnit.MILLISECONDS.sleep(time);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(time + " " + Thread.currentThread().getName());
		}
		
	}
}
```

在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。 

所谓守护 线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。

将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：

(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 

(2) 在Daemon线程中产生的新线程也是Daemon的。

(3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

#### 实例

> 1. 并行计算20万以内的质数

```java
public class T07_ParallelComputing {
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		long start = System.currentTimeMillis();
		List<Integer> res = getPrime(1,200000);
		long end = System.currentTimeMillis();
		System.out.println(end - start);
		
		final int cpuCoreNum = 4;
		
		ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);		
		Mytask t1 = new Mytask(1,80000);
		Mytask t2 = new Mytask(80000,130000);
		Mytask t3 = new Mytask(130000,180000);
		Mytask t4 = new Mytask(180000,200000);
		
		Future<List<Integer>> f1 = service.submit(t1);
		Future<List<Integer>> f2 = service.submit(t2);
		Future<List<Integer>> f3 = service.submit(t3);
		Future<List<Integer>> f4 = service.submit(t4);
		
		start = System.currentTimeMillis();
		f1.get();
		f2.get();
		f3.get();
		f4.get();
		end = System.currentTimeMillis();
		System.out.println(end - start);
		service.shutdown();
		
	}
	static class Mytask implements Callable<List<Integer>>{
		int startPos,endPos;
		Mytask(int s, int e){
			this.startPos = s;
			this.endPos = e;
		}
		@Override
		public List<Integer> call() throws Exception {
			List<Integer> res = getPrime(startPos,endPos);
			return res;
		}
	}
	static boolean isPrime(int num) {
		for(int i = 2; i <= num / 2 ; i++) {
			if(num % i == 0) {
				return false;
			}
		}
		return true;
	}
	static List<Integer> getPrime(int start, int end){
		List<Integer> res = new ArrayList<>();
		for(int i = start; i <= end; i++) {
			if(isPrime(i)) {
				res.add(i);
			}
		}
		return res;
	}
}
```

------

> 2. 并行计算100万个随机数的总和

```java
public class T12_ForkJoinPool {
	static int[] nums = new int[1000000];
	static final int MAX_NUM = 50000;//切分阈值
	static Random r = new Random();
	static {
		for(int i = 0; i < nums.length; i++) {
			nums[i] = r.nextInt(100);
		}
	}
	//recursiveAction 没有返回值
	/*static class AddTask extends RecursiveAction{
		int start,end;
		AddTask(int s, int e){
			this.start = s;
			this.end = e;
		}
		@Override
		protected void compute() {
			if(end -start <= MAX_NUM) {
				long sum = 0L;
				for(int i = start; i < end ;i++) {
					sum += nums[i];
				}
				System.out.println(" from "+start+" to: "+end+" = "+sum);
				 
			}else {
				int middle = start + (end -start)/2;
				AddTask subTask1 = new AddTask(start,middle);
				AddTask subTask2 = new AddTask(middle,end);
				subTask1.fork();
				subTask2.fork();
			}
		}
	}*/
	static class AddTask extends RecursiveTask<Long>{
		int start,end;
		AddTask(int s, int e){
			this.start = s;
			this.end = e;
		}
		
		@Override
		protected Long compute() {
			if(end -start <= MAX_NUM) {
				long sum = 0L;
				for(int i = start; i < end ;i++) {
					sum += nums[i];
				}
				System.out.println(Thread.currentThread().getName() + " from "+start+" to: "+end+" = "+sum);
				return sum;
			}else {
				int middle = start + (end -start)/2;
				AddTask subTask1 = new AddTask(start,middle);
				AddTask subTask2 = new AddTask(middle,end);
				subTask1.fork();
				subTask2.fork();
				return subTask1.join()+subTask2.join();
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		ForkJoinPool fkpool = new ForkJoinPool();
		
		long start = System.currentTimeMillis();
		System.out.println(Arrays.stream(nums).sum());//stream api
		long end = System.currentTimeMillis();
		System.out.println(end - start);
		
		start = System.currentTimeMillis();
		AddTask task = new AddTask(0,nums.length);
		fkpool.execute(task);
		long result = task.join();
		System.out.println(result);
		end = System.currentTimeMillis();
		System.out.println(end - start);
		//System.in.read();
	}
}
```

