---
title: 同步容器与并发容器
date: 2019-08-05 11:54:15
tags:
- Java
- Concurrent
categories:
- Java
- Concurrent
---
# 同步容器与并发容器

### 同步容器

​		同步容器可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。

​		Java同步容器有`Vector`,`Stack`,`HashTable`,或者用`Collections.synchronized`生成。同步容器在单线程的环境下能够保证线程安全，但是通过synchronized同步方法将访问操作串行化，导致并发环境下效率低下。而且同步容器在多线程环境下的复合操作（迭代、条件运算如没有则添加等）是非线程安全，需要客户端代码来实现加锁。

> 代码示例

假设有n张火车票，每张票都有一个编号，同时有十个窗口对外售票，模拟一下过程。

1. ArrayList()

```java
public class TicketSeller1 {
	static List<String> tickets = new ArrayList<>();
	static {
		for(int i = 0; i < 10000; i++) {
			tickets.add("票编号=" + i);
		}
	}
	
	public static void main(String[] args) {
		for(int i = 0; i < 10; i++) {
			new Thread(()->{
				while(tickets.size() > 0){
					System.out.println("销售了--"+tickets.remove(0));
				}
			}).start();
		}
	}
}
```

​		在上面代码中，有10000张火车票，每张票都有一个编号，同时有十个窗口对外售票，模拟售票过程。由于用的不是同步容器，所以会产生重复售票或者超量销售问题。

```
2. Vector
```

```java
public class TicketSeller2 {
	static Vector<String> tickets = new Vector<String>();
	static {
		for(int i = 0; i < 1000; i++) {
			tickets.add("票编号=" + i);
		}
	}
	
	public static void main(String[] args) {
		for(int i = 0; i < 10; i++) {
			new Thread(()->{
				while(tickets.size() > 0){
					try {
						TimeUnit.MILLISECONDS.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println("销售了--"+tickets.remove(0));
				}
			}).start();
		}
	}
}
```

> 如果使用同步容器`Vector`是否可以正常销售呢？

​	不能，`Vector`是同步容器，`size()`和`remove()`方法都是同步方法，但是组合在一起不是一个原子操作，判断和操作没有同步。

3. 对tickets上锁

```java
public class TicketSeller3 {
	static List<String> tickets = new LinkedList<String>();
	static {
		for(int i = 0; i < 1000; i++) {
			tickets.add("票编号=" + i);
		}
	}
	
	public static void main(String[] args) {
		for(int i = 0; i < 10; i++) {
			new Thread(()->{
				while(true) {
					synchronized(tickets) {
						if(tickets.size() <= 0) break;
						try {
							TimeUnit.MILLISECONDS.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("销售了--"+tickets.remove(0));
					}
				}
			}).start();
		}
	}
}
```

​		在上面的代码中，尽管用的不是同步容器`LinkedList`，但是对`tickets`上锁，使判断和操作变为了原子操作，但是效率会比较低。

------

### 并发容器

由上面的分析我们知道，同步容器并不能保证多线程安全，而并发容器是针对多个线程并发访问而设计的，在jdk5.0引入了concurrent包，其中提供了很多并发容器，极大的提升同步容器类的性能。

#### ConcurrentHashMap

​		对应的非并发容器`HashMap`，用于代替`Hashtable`，支持复合操作。JDK6中采用一种更加细粒度的加锁机制Segment“分段锁”，JDK8中采用CAS无锁算法。

> Hashtable和ConcurrentHashMap比较

```java
public class T01_ConcurrentMap {
	public static void main(String[] args) {
		Map<String,String> map = new Hashtable<>();
		
		//Map<String,String> map = new ConcurrentHashMap<>();
        //Map<String,String> map = new ConcurrentSkipListMap<>();//高并发并且排序
		Random r = new Random();
		Thread[] ths = new Thread[100];
		CountDownLatch latch = new CountDownLatch(ths.length);
		long start = System.currentTimeMillis();
		for(int i = 0; i < ths.length; i++) {
			ths[i] = new Thread(()->{
				for(int j = 0; j< 10000; j++) {
					map.put("a" + r.nextInt(100000), "a"+ r.nextInt(100000));
					latch.countDown();
				}
			});
		}
		Arrays.asList(ths).forEach(t->t.start());
		try {
			latch.await();//主线程等待其他线程结束
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		long end = System.currentTimeMillis();
		System.out.println(end-start);
	}
}
```

可以看到高并发下，`ConcurrentHashMap`比`Hashtable`效率更高，`ConcurrentHashMap`采用了一种更加细粒度的加锁机制，分段锁。

------

#### ConcurrentSkipListMap

​		`Skip list`（跳表）是一种可以代替平衡树的数据结构，默认是按照Key值升序的。Skip list让已排序的数据分布在多层链表中，以0-1随机数决定一个数据的向上攀升与否，通过”空间来换取时间”的一个算法。`ConcurrentSkipListMap`提供了一种线程安全的并发访问的排序映射表。内部是`SkipList`（跳表）结构实现，在理论上能够在`O(log(n))`时间内完成查找、插入、删除操作。

具体可以[参考链接](https://blog.csdn.net/sunxianghuang/article/details/52221913)

------

#### CopyOnWriteAyyayList

​		对应的非并发容器`ArrayList`，利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过`volatile` 保证其可见性，当然写操作的锁是必不可少的了。适用于读多写少的情况。

代码示例：

```java
public class T02_CopyOnWriteList {
	public static void main(String[] args) {
		List<String> lists = 
				new ArrayList<>(); // 有并发问题
				//new Vector<>();
				//new CopyOnWriteArrayList<>();
		Random r = new Random();
		Thread[] ths = new Thread[100];
		for(int i = 0; i < ths.length; i++) {
			Runnable task = new Runnable() {
				@Override
				public void run() {
					for(int i = 0; i < 1000; i++) {
						lists.add("a" + r.nextInt(10000));
					}
				}
			};
			ths[i] = new Thread(task);
		}
		runAndComputeTime(ths);
		System.out.println(lists.size());
	}
	static void runAndComputeTime(Thread[] ths) {
		long start = System.currentTimeMillis();
		Arrays.asList(ths).forEach(t->t.start());
		Arrays.asList(ths).forEach(t->{
			try {
				t.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		});
		long end = System.currentTimeMillis();
		System.out.println(end-start);
	}
}
```

​		一共有100个线程，每个线程向`lists`中添加1000个随机字符串，计算时间。分别运行三种情况，`ArrayList`时间在100ms左右，但是`lists.size()`小于十万，`Vector`时间也在100ms左右`lists.size()`等于十万，,`CopyOnWriteArrayList`的时间远远大于100ms,大概在5000ms，由此可见，`CopyOnWriteArrayList`不适合用在写多读少的情况下。

------

#### ConcurrentLinkedQueue

​	不会阻塞的队列，基于链表实现的FIFO队列。

#### LinkedBlockingQueue

​	`LinkedBlockingQueue`可以是有界的也可以是无界的(`Integer.MAX_VALUE`)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。

​	`LinkedBlockingQueue`是一个阻塞队列，内部由两个`ReentrantLock`来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。

> 模拟消费者生产者

```java
public class T05_LinkedBlockingQueue {//无界队列
	static BlockingQueue<String> strs = new LinkedBlockingQueue<>();
	static Random r = new Random();
	public static void main(String[] args) {
		new Thread(()->{
			for(int i = 0; i < 100 ; i++) {
				try {
					strs.put("a" + i);//如果满了，就会等待
					TimeUnit.MILLISECONDS.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		},"p1").start();
		for(int i = 0; i < 5; i++) {
			new Thread(()->{
				for(;;) {
					try {
						//take 如果空了，就会等待 
						System.out.println(Thread.currentThread().getName()+ " take " + strs.take());
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			},"c" + i).start();
		}
	}
}
```

------

#### ArrayBlockingQueue

​		有界队列，`ArrayBlockingQueue`是有界的初始化必须指定大小，采用的是数组作为数据存储容器。

​		`LinkedBlockingQueue`是一个阻塞队列，内部由两个`ReentrantLock`来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和`ArrayBlockingQueue`的不同点在于：

- 队列大小有所不同，`ArrayBlockingQueue`是有界的初始化必须指定大小，而`LinkedBlockingQueue`可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。
- 数据存储容器不同，`ArrayBlockingQueue`采用的是数组作为数据存储容器，而`LinkedBlockingQueue`采用的则是以Node节点作为连接对象的链表。
- 由于`ArrayBlockingQueue`采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而`LinkedBlockingQueue`则会生成一个额外的`Node`对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。
- 两者的实现队列添加或移除的锁不一样，`ArrayBlockingQueue`实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个`ReenterLock`锁，而`LinkedBlockingQueue`实现的队列中的锁是分离的，其添加采用的是`putLock`，移除采用的则是`takeLock`，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

------

#### DelayQueue

​		`DelayQueue`是一个支持延时获取元素的无界阻塞队列。队列使用`PriorityQueue`来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。

代码示例：

```java
public class T07_DelayQueue {
	static BlockingQueue<Mytask> tasks = new DelayQueue<>();
	static Random r = new Random();
	static class Mytask implements Delayed{
		long runningTime;
		Mytask(long rt){
			this.runningTime = rt;
		}
		@Override
		public int compareTo(Delayed o) {
			long l1 = this.getDelay(TimeUnit.MILLISECONDS);
			long l2 = o.getDelay(TimeUnit.MILLISECONDS);
			return l1 > l2 ? 1 : (l1 == l2 ? 0 : -1);
		}

		@Override
		public long getDelay(TimeUnit unit) {
			return unit.convert(runningTime-System.currentTimeMillis(), TimeUnit.MILLISECONDS);
		}
		@Override
		public String toString() {
			return "Mytask [runningTime=" + runningTime + "]";
		}
		
	}
	public static void main(String[] args) throws InterruptedException {
		long now = System.currentTimeMillis();
		Mytask t1 = new Mytask(now + 1000);
		Mytask t2 = new Mytask(now + 2000);
		Mytask t3 = new Mytask(now + 3000);
		Mytask t4 = new Mytask(now + 4000);
		Mytask t5 = new Mytask(now + 5000);
		tasks.put(t1);
		tasks.put(t2);
		tasks.put(t3);
		tasks.put(t4);
		tasks.put(t5);
		System.out.println(tasks);
		for (int i = 0; i < 5; i++) {
			System.out.println(tasks.take());
		}
	}
}
```

------

#### LinkedTransferQueue

​		`LinkedTransferQueue`是一个由链表结构组成的无界阻塞`TransferQueue`队列。相对于其他阻塞队列，`LinkedTransferQueue`多了`tryTransfe`r和`transfer`方法。

```java
public class T08_TransferQueue {
	public static void main(String[] args) throws InterruptedException {
		LinkedTransferQueue<String> queue = new LinkedTransferQueue<>();
		new Thread(()->{
			try {
				System.out.println(queue.take());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}).start();

		queue.transfer("aaa");//搬运到消费者线程 没有消费者线程就会阻塞
		
		/*new Thread(()->{
			try {
				System.out.println(queue.take());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}).start();*/
	}
}
```

​		简单用法

`put()`：放入元素到队列中，队列可以是无限长的。

`add()`：同上。

`transfer()`：如果队列中有其他线程在等待，则直接运送给线程，否则放入队列。

`poll()`：立即返回，没有元素为空。

`take()`：如果队列中没有元素，则等待。

------

#### SynchronousQueue

​		`SynchronousQueue`是一个双栈双队列算法，无空间的队列或栈，任何一个对`SynchronousQueue`写需要等到一个对`SynchronousQueue`的读操作，反之亦然。一个读操作需要等待一个写操作，相当于是交换通道，提供者和消费者是需要组队完成工作，缺少一个将会阻塞线程，知道等到配对为止。

```java
public class T09_SynchronousQueue {
	public static void main(String[] args) throws InterruptedException {
		SynchronousQueue<String> queue = new SynchronousQueue<>();
		new Thread(()->{
			try {
				System.out.println(queue.take());
				
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}).start();
		
		//queue.add("bbb");//异常
		queue.put("aaa");
		//阻塞等待消费者消费
		System.out.println(queue.size());
	}
}
```

