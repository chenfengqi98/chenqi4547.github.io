---
title: 生产者消费者问题
date: 2019-08-04 10:55:45
tags:
- Java
- Concurrent
- Producer-Consumer-Problem
categories:
- Java
- Concurrent
- Producer-Consumer-Problem
---
# 生产者消费者问题

### 概述

> ​	生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。 
>
> 要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。

------

### 问题描述

> 写一个固定容量的同步容器，拥有`get()`和`put()`方法，以及`getCount()`方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用。

------

### 分析

该问题需要注意的几点： 

- 在缓冲区为空时，消费者不能再进行消费 
- 在缓冲区为满时，生产者不能再进行生产 
- 在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步 
- 注意条件变量与互斥锁的顺序

### 实现

方法1：使用`notifyAll()`和`wait()`实现

```java
public class MyContainer1<T> {
	final private LinkedList<T> lists = new LinkedList<>();
	final private int MAX = 10;
	private int count = 0;
	public synchronized void put(T t) {
		while(lists.size() == MAX) {//为什么用while而不是if 虚假唤醒问题
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		lists.add(t);
		++count;
		this.notifyAll();//不能用notify
	}
	public synchronized T get() {
		while(lists.size() == 0) {
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		T t = lists.removeFirst();
		count--;
		this.notifyAll();
		return t;
	}
	public static void main(String[] args) {
		MyContainer1<String> c = new MyContainer1<>();
		//启动消费者线程
		for(int i = 0; i < 10; i++) {
			new Thread(()->{
				for(int j = 0; j < 5; j++) {
					System.out.println(c.get());
					try {
						TimeUnit.SECONDS.sleep(1);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			},"c"+i).start();
		}
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		//启动生产者线程
		for(int i = 0; i < 2; i++) {
			new Thread(()->{
				for(int j = 0; j < 25; j++) {
					c.put(Thread.currentThread().getName()+" "+j);	
				}
			},"p"+i).start();
		}
	}
}
```

> 思考一下为什么要用`while(lists.size() == MAX)`而不用`if(lists.size() == MAX)`?

​	虚假唤醒问题，假如容器已满，两个生产者线程都在等待消费者消费，当某个消费者拿走一个后，`notifyAll()`其他线程，此时两个生产者都被唤醒，此时假设生产线程`p1`获得锁，进行生产，`p1`执行完后释放了锁，生产线程`p0`获得锁，如果不是用的`while()`判断，`p0`拿到锁之后不会循环判断容器是否满了，而是直接执行`this.wait()`后面的代码，然后造成溢出。

------

方法2：使用`lock`和`condition`来实现 

```java
public class MyContainer2<T> {
	final private LinkedList<T> lists = new LinkedList<>();
	final private int MAX = 10;
	private int count = 0;

	private Lock lock = new ReentrantLock();
	private Condition producer = lock.newCondition();
	private Condition consumer = lock.newCondition();

	public void put(T t) {
		try {
			lock.lock();
			while (lists.size() == MAX) {
				producer.await();
			}
			lists.add(t);
			++count;
			consumer.signalAll();// 通知消费者线程进行消费
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}

	public T get() {
		T t = null;
		try {
			lock.lock();
			while (lists.size() == 0) {
				consumer.await();
			}
			t = lists.removeFirst();
			--count;
			producer.signalAll();// 通知生产者进行生产
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
		return t;
	}

	public static void main(String[] args) {
		MyContainer2<String> c = new MyContainer2<>();
		// 启动消费者线程
		for (int i = 0; i < 10; i++) {
			new Thread(() -> {
				for (int j = 0; j < 5; j++) {
					System.out.println(c.get());
					try {
						TimeUnit.SECONDS.sleep(1);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}, "c" + i).start();
		}
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		// 启动生产者线程
		for (int i = 0; i < 2; i++) {
			new Thread(() -> {
				for (int j = 0; j < 25; j++) {
					c.put(Thread.currentThread().getName() + " " + j);
					/*try {
						TimeUnit.SECONDS.sleep(1);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}*/
				}
			}, "p" + i).start();
		}
	} 
}

```

Condition的方式可以更加精确的指定哪些线程被唤醒。

> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，阻塞队列实际上是使用了Condition来模拟线程间协作。